## 2. 링커와 로더

### 2.1 링커의 역할과 작동 원리

**이론**

**링커 (Linker)**는 여러 개의 오브젝트 파일을 하나의 실행 가능한 파일로 결합하는 역할을 합니다. 오브젝트 파일은 컴파일러가 각 소스 파일을 기계어로 변환한 결과입니다. 링커는 이 오브젝트 파일들 간의 심볼 참조를 해결하고, 필요한 라이브러리 코드를 포함하여 최종 실행 파일을 생성합니다.

**링커의 주요 역할**:
1. **주소 할당 (Address Binding)**: 오브젝트 파일 내의 기호(Symbol)에 실제 메모리 주소를 할당합니다.
2. **심볼 해결 (Symbol Resolution)**: 각 오브젝트 파일에서 정의된 심볼과 참조된 심볼을 결합합니다.
3. **재배치 (Relocation)**: 코드와 데이터의 상대 주소를 실제 메모리 주소로 변환합니다.

**링커의 종류**:
1. **정적 링커 (Static Linker)**: 모든 코드와 데이터가 실행 파일에 포함됩니다. 실행 파일은 자체적으로 완전하며, 실행 시 추가적인 라이브러리가 필요하지 않습니다.
2. **동적 링커 (Dynamic Linker)**: 실행 시점에 필요한 라이브러리를 로드합니다. 실행 파일은 외부 라이브러리와 함께 동작합니다.

### 링커의 작동 원리

1. **오브젝트 파일 읽기**:
   - 링커는 입력으로 주어진 여러 오브젝트 파일을 읽습니다.

2. **심볼 테이블 생성 및 병합**:
   - 각 오브젝트 파일에는 정의된 심볼과 참조된 심볼의 목록이 있는 심볼 테이블이 포함되어 있습니다.
   - 링커는 이 심볼 테이블을 병합하여 전체 프로그램의 심볼 테이블을 생성합니다.

3. **주소 재배치**:
   - 각 오브젝트 파일 내의 코드와 데이터는 상호 독립적으로 컴파일되었기 때문에, 상대 주소를 사용합니다.
   - 링커는 이 상대 주소를 실제 메모리 주소로 재배치합니다.

4. **심볼 해결**:
   - 링커는 각 심볼 참조를 해당 심볼 정의로 해결합니다.
   - 만약 심볼이 정의되지 않았거나, 중복 정의된 경우 에러를 발생시킵니다.

5. **실행 파일 생성**:
   - 모든 심볼 참조가 해결되고 주소가 재배치된 후, 링커는 최종 실행 파일을 생성합니다.

### 예제

다음은 간단한 프로그램을 컴파일하고 링크하는 과정을 보여줍니다.

#### 1. 소스 파일 작성

**main.c**

```c
#include <stdio.h>

extern int add(int, int);

int main() {
    int a = 5;
    int b = 10;
    int result = add(a, b);
    printf("Result: %d\n", result);
    return 0;
}
```

**add.c**

```c
int add(int a, int b) {
    return a + b;
}
```

#### 2. 컴파일

각 소스 파일을 오브젝트 파일로 컴파일합니다.

```sh
gcc -c main.c -o main.o
gcc -c add.c -o add.o
```

#### 3. 링킹

오브젝트 파일을 링크하여 실행 파일을 생성합니다.

```sh
gcc main.o add.o -o program
```

이 과정에서 링커는 `main.o`와 `add.o`의 심볼 테이블을 결합하고, 심볼 참조를 해결하며, 주소를 재배치하여 최종 실행 파일 `program`을 생성합니다.

### 실습 과제

#### 과제 1: 링커의 심볼 해결 과정 이해하기

**목표**:
- 주어진 오브젝트 파일의 심볼 테이블을 분석하고, 링커가 심볼 참조를 어떻게 해결하는지 이해합니다.

**해설**:
- `nm` 명령어를 사용하여 오브젝트 파일의 심볼 테이블을 확인합니다.
- 각 심볼의 정의와 참조를 분석하여 링커가 심볼을 어떻게 해결하는지 이해합니다.

```sh
nm main.o
nm add.o
```
