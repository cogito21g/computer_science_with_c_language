## 2. 링커와 로더

### 2.2 로더의 역할과 작동 원리

**이론**

**로더 (Loader)**는 실행 파일을 메모리에 적재하고 실행 준비를 하는 역할을 합니다. 운영체제가 프로그램을 실행할 때 로더가 호출되어 이 작업을 수행합니다. 로더는 실행 파일을 메모리의 적절한 위치에 로드하고, 프로그램의 시작 주소로 제어를 넘깁니다.

**로더의 주요 역할**:
1. **실행 파일 로드 (Loading Executable)**: 실행 파일을 디스크에서 메모리로 읽어옵니다.
2. **주소 재배치 (Relocation)**: 실행 파일의 상대 주소를 실제 메모리 주소로 변환합니다.
3. **프로그램 시작 (Program Start)**: 프로그램의 시작 주소로 제어를 넘깁니다.

### 로더의 작동 원리

1. **실행 파일 읽기**:
   - 로더는 실행 파일을 디스크에서 읽습니다.
   - 실행 파일의 포맷(예: ELF, PE 등)을 이해하고, 파일 헤더를 분석합니다.

2. **메모리 할당**:
   - 로더는 프로그램이 실행될 메모리 공간을 할당합니다.
   - 실행 파일의 코드, 데이터, 힙, 스택 섹션을 메모리에 배치합니다.

3. **주소 재배치**:
   - 실행 파일에 포함된 주소가 실제 메모리 주소로 변경됩니다.
   - 코드와 데이터 섹션의 상대 주소를 실제 메모리 주소로 재배치합니다.
   - 실행 파일의 재배치 정보를 사용하여 심볼과 주소를 해결합니다.

4. **프로그램 시작**:
   - 로더는 프로그램의 시작 주소로 제어를 넘기고, 프로그램을 실행합니다.
   - 프로그램의 엔트리 포인트(보통 `main` 함수)로 점프합니다.

### 로더의 주요 단계

1. **로드 시간에 로딩 (Load-Time Loading)**:
   - 프로그램 실행 전에 모든 코드와 데이터를 메모리에 로드합니다.
   - 주로 정적 링크된 프로그램에서 사용됩니다.

2. **실행 시간에 로딩 (Run-Time Loading)**:
   - 프로그램 실행 중에 필요할 때마다 코드와 데이터를 메모리에 로드합니다.
   - 주로 동적 링크된 프로그램에서 사용됩니다.

### 예제

다음은 프로그램을 로드하고 실행하는 과정을 간단히 설명합니다.

1. **프로그램 실행**:
   - 사용자가 프로그램을 실행합니다. 예: `./program`

2. **운영체제 호출**:
   - 운영체제는 로더를 호출하여 프로그램을 메모리에 로드합니다.

3. **메모리 할당 및 재배치**:
   - 로더는 프로그램을 메모리에 할당하고, 주소를 재배치합니다.

4. **프로그램 시작**:
   - 로더는 프로그램의 시작 주소로 제어를 넘기고, 프로그램을 실행합니다.

### 실습 과제

#### 과제 1: 로더의 주소 재배치 과정 이해하기

**목표**:
- 주어진 실행 파일의 메모리 레이아웃을 분석하고, 로더가 주소를 어떻게 재배치하는지 이해합니다.

**해설**:
- `objdump` 명령어를 사용하여 실행 파일의 메모리 레이아웃을 확인합니다.
- 각 주소의 재배치 과정을 분석합니다.

```sh
objdump -d program
```

실행 파일 `program`의 어셈블리 코드를 덤프하여 메모리 레이아웃과 재배치된 주소를 확인할 수 있습니다.

#### 과제 2: 동적 라이브러리 사용 프로그램 분석

**목표**:
- 동적 라이브러리를 사용하는 프로그램에서 로더가 어떻게 동작하는지 이해합니다.

**해설**:
- `ldd` 명령어를 사용하여 프로그램이 사용하는 동적 라이브러리를 확인합니다.
- 동적 라이브러리의 로딩 과정을 분석합니다.

```sh
ldd program
```

프로그램 `program`이 실행 시 사용하는 동적 라이브러리 목록을 확인할 수 있습니다.

### 코드 예제

다음은 간단한 프로그램이 메모리에 로드되고 실행되는 과정을 이해하기 위한 예제 코드입니다.

#### 1. 소스 파일 작성

**main.c**

```c
#include <stdio.h>

extern int add(int, int);

int main() {
    int a = 5;
    int b = 10;
    int result = add(a, b);
    printf("Result: %d\n", result);
    return 0;
}
```

**add.c**

```c
int add(int a, int b) {
    return a + b;
}
```

#### 2. 컴파일

각 소스 파일을 오브젝트 파일로 컴파일합니다.

```sh
gcc -c main.c -o main.o
gcc -c add.c -o add.o
```

#### 3. 링킹

오브젝트 파일을 링크하여 실행 파일을 생성합니다.

```sh
gcc main.o add.o -o program
```

이제 실행 파일 `program`이 생성되었습니다. 로더는 이 실행 파일을 메모리에 로드하고 실행할 준비를 합니다.

### 로더의 실제 동작 확인

실제 로더가 어떻게 동작하는지 이해하기 위해, `strace` 명령어를 사용하여 프로그램의 실행 과정을 추적할 수 있습니다.

```sh
strace ./program
```

`strace` 명령어는 프로그램이 실행되는 동안의 시스템 호출을 추적합니다. 이를 통해 로더가 어떻게 실행 파일을 메모리에 로드하고 실행하는지 확인할 수 있습니다.
