## 1. 컴파일러 내부 구조 이해

### 1.7 컴파일러 내부 구조 이해

**이론**

컴파일러는 고급 프로그래밍 언어로 작성된 소스 코드를 기계어 코드로 변환하는 프로그램입니다. 컴파일러는 일반적으로 여러 단계로 나누어져 있으며, 각 단계는 특정 작업을 수행합니다. 컴파일러의 내부 구조를 이해하는 것은 컴파일러 설계와 최적화의 기본입니다.

컴파일러의 주요 단계:
1. **어휘 분석 (Lexical Analysis)**: 소스 코드를 토큰으로 분해합니다.
2. **구문 분석 (Syntax Analysis)**: 토큰을 구문 트리(Syntax Tree)로 변환합니다.
3. **의미 분석 (Semantic Analysis)**: 구문 트리를 의미적으로 분석하여 오류를 검출합니다.
4. **중간 코드 생성 (Intermediate Code Generation)**: 구문 트리를 중간 코드로 변환합니다.
5. **중간 코드 최적화 (Intermediate Code Optimization)**: 중간 코드를 최적화합니다.
6. **기계어 코드 생성 (Code Generation)**: 중간 코드를 기계어 코드로 변환합니다.
7. **기계어 코드 최적화 (Code Optimization)**: 기계어 코드를 최적화합니다.

**컴파일러의 구성 요소**:
- **프론트엔드 (Frontend)**: 어휘 분석, 구문 분석, 의미 분석을 수행합니다.
- **미들엔드 (Middleend)**: 중간 코드 생성과 최적화를 수행합니다.
- **백엔드 (Backend)**: 기계어 코드 생성과 최적화를 수행합니다.

### 컴파일러의 구조

1. **어휘 분석 (Lexer)**
   - 소스 코드에서 토큰을 추출합니다.
   - 예: `int a = 5;` -> `int`, `a`, `=`, `5`, `;`

2. **구문 분석 (Parser)**
   - 토큰을 받아 구문 트리를 생성합니다.
   - 예: `int a = 5;` -> 구문 트리

3. **의미 분석 (Semantic Analyzer)**
   - 구문 트리를 받아 의미적 오류를 검사합니다.
   - 예: 타입 검사, 변수 선언 확인

4. **중간 코드 생성 (Intermediate Code Generator)**
   - 구문 트리를 중간 코드로 변환합니다.
   - 예: 3주소 코드

5. **중간 코드 최적화 (Intermediate Code Optimizer)**
   - 중간 코드를 최적화합니다.
   - 예: 불필요한 코드 제거, 상수 전파

6. **기계어 코드 생성 (Code Generator)**
   - 중간 코드를 기계어 코드로 변환합니다.
   - 예: 어셈블리 코드 생성

7. **기계어 코드 최적화 (Code Optimizer)**
   - 기계어 코드를 최적화합니다.
   - 예: 레지스터 할당 최적화

### 예제

간단한 컴파일러 구조를 이해하기 위해, 각 단계에서 수행되는 작업을 예제로 보여줍니다.

#### 1. 프로그램 작성 (`example.c`)

간단한 C 프로그램을 작성합니다.

```c
#include <stdio.h>

int main() {
    int a = 5;
    int b = 10;
    int sum = a + b;
    printf("Sum: %d\n", sum);
    return 0;
}
```

#### 2. 어휘 분석 (Lexer)

소스 코드를 토큰으로 분해합니다.

```text
int -> 키워드
main -> 식별자
( -> 구두점
) -> 구두점
{ -> 구두점
int -> 키워드
a -> 식별자
= -> 연산자
5 -> 숫자
; -> 구두점
...
```

#### 3. 구문 분석 (Parser)

토큰을 받아 구문 트리를 생성합니다.

```text
<프로그램>
    <함수 선언>
        <반환 타입> int
        <함수명> main
        <매개변수 리스트> ()
        <함수 몸체> {
            <선언문> int a = 5;
            ...
        }
```

#### 4. 의미 분석 (Semantic Analyzer)

구문 트리를 받아 의미적 오류를 검사합니다.

```text
<프로그램>
    <함수 선언>
        <반환 타입> int
        <함수명> main
        <매개변수 리스트> ()
        <함수 몸체> {
            <선언문> int a = 5; // OK
            ...
        }
```

#### 5. 중간 코드 생성 (Intermediate Code Generator)

구문 트리를 중간 코드로 변환합니다.

```text
t1 = 5
t2 = 10
t3 = t1 + t2
print t3
```

#### 6. 중간 코드 최적화 (Intermediate Code Optimizer)

중간 코드를 최적화합니다.

```text
// 상수 전파 적용
t1 = 5
t2 = 10
t3 = 5 + 10
print t3
// 결과: 불필요한 코드 제거
t3 = 15
print t3
```

#### 7. 기계어 코드 생성 (Code Generator)

중간 코드를 기계어 코드로 변환합니다.

```assembly
mov eax, 5
mov ebx, 10
add eax, ebx
mov ecx, eax
push ecx
call printf
```

#### 8. 기계어 코드 최적화 (Code Optimizer)

기계어 코드를 최적화합니다.

```assembly
mov eax, 15
push eax
call printf
```

### 실습 과제

#### 과제 1: 간단한 컴파일러 작성

**목표**:
- 주어진 소스 코드를 각 단계를 통해 기계어 코드로 변환하는 간단한 컴파일러를 작성합니다.

**해설**:
- 각 단계별로 함수나 클래스를 작성하여 컴파일러를 구현합니다.
- 어휘 분석기, 구문 분석기, 의미 분석기, 중간 코드 생성기, 최적화기, 기계어 코드 생성기를 구현합니다.
